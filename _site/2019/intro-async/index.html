<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Writing Async with Python | Stuffonmymind </title> <meta name="description" content=" Async "> <meta name="keywords" content="Learn"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="Sangarshanan"> <meta property="article:section" content=""> <meta property="article:tag" content="Learn"> <meta property="article:published_time" content="2019-11-05 00:00:00 +0530"> <meta property="og:url" content="http://localhost:4000/2019/intro-async/"> <meta property="og:title" content=" Writing Async with Python | Stuffonmymind "> <meta property="og:image" content="http://localhost:4000"> <meta property="og:description" content=" Async "> <meta property="og:site_name" content="Sangarshanan"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content=""> <meta name="twitter:title" content=" Writing Async with Python | Stuffonmymind "> <meta name="twitter:description" content=" Async "> <meta name="twitter:image:src" content="http://localhost:4000"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" Writing Async with Python | Stuffonmymind "> <meta itemprop="description" content=" Async "> <meta itemprop="image" content="http://localhost:4000"> <!-- Canonical link tag --> <link rel="canonical" href="http://localhost:4000/2019/intro-async/"> <link rel="alternate" type="application/rss+xml" title="Stuffonmymind" href="http://localhost:4000/feed.xml"> <!-- rel prev and next --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="http://localhost:4000/">Stuffonmymind<span></span></a></h1> <ul class="navbar"> <li><a href="http://localhost:4000/about">About me</a></li> <li><a href="https://medium.com/@sangarshananveera" target="_blank">Medium</a></li> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2019-11-05T00:00:00+05:30" itemprop="datePublished">Nov 5, 2019</time></p> <h1 class="post-title" itemprop="name headline">Writing Async with Python</h1> </header> <div class="post-content" itemprop="articleBody"> <p>&lt; Writing In Progress &gt;</p> <p>Bit late to this topic so I’m glad there are tons of resources around :)</p> <p>There are always ways to speed up your code, you can scale horizontally or vertically but maybe you can be effective without scaling. Maybe you run multiple operations in parallel or concurrent or maybe you write your code to run asynchronously. But what do all these smancy words actually mean</p> <p>Parallel vs Concurrent vs Async FIGHT !!!!</p> <ul> <li> <p>Parallel : Watch TV while eating Popcorn (You can do both of em at the simultaneously)</p> </li> <li> <p>Concurrency: Watch Tv while texting on the phone (You can deal with them simultaneously but not do em at the same time.. stop kidding yourself )</p> </li> <li> <p>Async: Look at your phone when you get a notification cause your meme is poppin and then quickly back to the TV cause it’s game weekkk !!!! (It is more a style of writing code)</p> </li> </ul> <p><a href="https://www.youtube.com/watch?v=cN_DpYBzKso">Amazing explanation by Rob Pike</a></p> <h3 id="what-is-async--and-asyncio-">What is Async ? and Asyncio ?</h3> <p>Asynchronous Programming is a style of concurrent programming where you do multiple things at once</p> <p>There are several ways to achieve this… Asyncio is one of those ways and is quite popular</p> <h3 id="how-can-i-do-multiple-things-at-once-">How can I do multiple things at once ?</h3> <ul> <li>Use multiple processes. Let OS handle sharing of CPU resources</li> <li>Use multiple threads. Threads share access to common resources as you can have multiple threads in the context of one process and they need to share a common resource but in Cpython the GIL (Global interpreter lock) prevents multi core concurrency :(</li> <li>or run multiple processes on the same thread asynchronously</li> </ul> <p>When depending on the OS one needs to take care of race-conditions, dead-locks, live-locks, and resource-starvation since we have to take care of several spawned threads trying to do stuff and that is in itself is a whole other topic of discussion. AsyncIO avoids some of the potential speedbumps that you might otherwise encounter with a threaded design.</p> <h3 id="what-is-async-doing--the-chess-analogy">What is Async doing ? (The chess analogy)</h3> <p>Async just optimizes the way things are done… it does not speed anything up.</p> <p>Suppose a chess grandmaster has to play with 10 opponents, he can play the game two ways</p> <ul> <li>Complete the game with one and move to the next one (Sync)</li> <li>Complete a move with one and move on the next player allowing the former player to think about what to do next thus saving the time you waste on waiting for the player to make a move (Async)</li> </ul> <p>Async tasks that are running release the CPU during waiting times so that other tasks can use it.. Simple</p> <h3 id="achieving-async-without-the-help-of-your-os">Achieving Async without the help of your OS</h3> <p>So to achieve async our tasks need to release the CPU and wait and then resume after sometime, We just need python functions that can be used to Suspend / Resume and also somewhere to keep track of all the tasks that are suspended so we can resume them later</p> <p>A function enters waiting period when suspended and only resumes when the wait is over</p> <p>Several ways to implement suspend/resume in python (some below)</p> <ul> <li>Callback functions</li> </ul> <p>Callbacks are often used in situations where an action is asynchronous. If you need to call a function, and immediately continue working, cause you can’t sit there wait for it to run and return a value ,so you provide a callback. When the function is done with it’s asynchronous work, it will then invoke your callback with some predetermined arguments (usually some you supply, and some about the status and result of the asynchronous action you requested).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">arithmetic</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">num</span><span class="p">:</span>
        <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">num</span><span class="o">**</span><span class="mi">3</span>

<span class="k">print</span><span class="p">(</span><span class="n">arithmetic</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">square</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">arithmetic</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">cube</span><span class="p">))</span>

<span class="p">[</span><span class="n">OUTPUT</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">125</span><span class="p">]</span>
</code></pre></div></div> <ul> <li>Generator Functions</li> </ul> <p>Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly by calling yield</p> <p>We should use yield when we want to iterate over a sequence but don’t want to store the entire sequence in memory.</p> <p>The yield statement suspends the function’s execution and sends a value back to the caller, but retains enough state to enable the function to resume where it is left off. When resumed, the function continues the execution immediately after the last yield run. This allows its code to produce a series of values over time rather them computing them all at once and sending them back like a list</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generator_function</span><span class="p">():</span>
    <span class="k">yield</span> <span class="s">"something"</span>
    <span class="k">yield</span> <span class="s">"other thing"</span>

<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">generator_function</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">generator_function</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__next__</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__next__</span><span class="p">())</span>

<span class="p">[</span><span class="n">OUTPUT</span><span class="p">]</span>
<span class="n">something</span>
<span class="n">other</span> <span class="n">thing</span>
<span class="n">something</span>
<span class="n">other</span> <span class="n">thing</span>

</code></pre></div></div> <p>Hmmm, suspend execution ? sounds like something we have been looking for (async). So maybe with generators we can perform asynchronous iterations. Well yes !!!</p> <p>PEP 525 introduced Asynchronous Generators <a href="https://www.python.org/dev/peps/pep-0525/">https://www.python.org/dev/peps/pep-0525/</a></p> <p>Async generators require two special methods to be implemented:</p> <ul> <li>An <strong>aiter</strong> method returning an asynchronous iterator.</li> <li> <p>An <strong>anext</strong> method returning an awaitable object, which uses StopIteration exception to “yield” values, and StopAsyncIteration exception to signal the end of the iteration.</p> </li> <li>Async/ Await</li> <li>Greenlets</li> </ul> <p>How do we decide which function gets the CPU next ? We need some kind of scheduler that takes care of this. We call it an event loop. Loop keeps track of all running tasks</p> <p>When a function is suspended it returns control to the loop which then finds another function to start or resume</p> <p>This is cooperative multitasking</p> <p>Asyncio implements asynchronous code with the help of</p> <p>Couroutines: Basically these are functions whose executions can be paused, They are used for cooperative multitasking where a process voluntarily yields control and enables multiple processes to run. When we declare a function using the async keyword the function is not run, instead, a coroutine object is returned</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
	<span class="k">pass</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">hello</span><span class="p">))</span>
</code></pre></div></div> <p>This returns a <code class="highlighter-rouge">&lt;class 'coroutine'&gt;</code></p> <p>There are two ways to read the output of an async function from a coroutine.</p> <p>The first way is to use the await keyword, this is possible only inside async functions and will wait for the coroutine to terminate and return the result</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">add_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="k">await</span> <span class="n">add_numbers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div> <p>OUTPUT: 12</p> <p>The second way is to add it to an event loop</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">add_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
<span class="n">coroutine</span> <span class="o">=</span> <span class="n">add_numbers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div> <p>OUTPUT = 12</p> <h3 id="when-not-use-async">When not use Async</h3> <ul> <li> <p>Long CPU intensive task must call sleep so that other functions get a chance too.. Release CPU to avoid starvation This can be done by sleeping periodically, once per iteration (Just sleep(0) once per loop)</p> </li> <li> <p>Blocking library functions are incompatible with async frameworks (socket select subprocess threading time.sleep) async provides non blocking replacements for these</p> </li> <li> <p>Evenlet and gevent can monkeypatch standard libraries to make it async compatible</p> </li> </ul> <p>Eveentlet, gevent try to hide async under the rug (abstracts it away) while asyncio wants you to think asycnhronously</p> <h3 id="totally-ripped-off-these">Totally ripped off these</h3> <p><a href="https://www.youtube.com/watch?v=iG6fr81xHKA">https://www.youtube.com/watch?v=iG6fr81xHKA</a></p> <p><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/">https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/</a></p> <p><a href="https://dev.to/welldone2094/async-programming-in-python-with-asyncio-12dl">https://dev.to/welldone2094/async-programming-in-python-with-asyncio-12dl</a></p> </div> </article> <footer class="site-footer"> <div class="container"> <small class="block">&copy; 2020 Sangarshanan &middot; &lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/thinkspace">thinkspace theme</a></small> </div> </footer> </main> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-XXXXX-XX']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> </body> </html>
