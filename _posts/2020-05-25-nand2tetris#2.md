---
layout: post
title: "Notes on nand2tetris #2"
comments: false
description: MOOC 
keywords: "Learn"
header-style: text
tags:
    - learning
    - series
---


We ended part 1 with the building out the hardware for our computer and also managed to write a low level language that can run instructions on top the our hardware, Now we move on to ze software (YAY) we start with the overview 

- Think of something cool 
- We write a program in a high level language 
- Compiler compiles high level code to an intermediatory VM code
- VM translator converts it to assembly code 
- Yoo now we can run this on our hardware

We missed the OS, this is gonna be used by our high level lang for doing stuff like graphics, IO from files, reading keyboard input, Storing objects, threads and so much more that we as programmers dont have to worry about... mostly


### Virtual Machines 

The problem with building compilers for high level language to machine language is that different machines have different architecture and hence would need a different compiler, which sucks. 

> An alternative/ better approach is "Write one Run Anywhere"

For example Java compiles to Bytecode (VM code) that inturn runs with the help of JVM (java virtual machine) on different kinda hardware and ensures interoperability. This idea is called 2 tier compilation and was actually conceptualized by Turing

For our VM implementation we are gonna use the stack machine, which is nothing but an abstraction that consists of a stack and a set of operations we can apply to this architecture


<b> Stack Machine: </b>

A stack is a basic data structure that can be logically thought of as a linear structure represented by a real physical stack or pile, a structure where insertion and deletion of items takes place at one end called top of the stack and also stack pointer.

We have two major stack operations:
- Push x: Moves the value from memory location x to the stack pointer

- Pop y: Moved the value from the stack pointer to the memory location y

Using this we also perform arithmetic operations on the stack, like add and sub


| Stack => ADD  |      Stack  => NEG  | Stack |
|----------|:-------------:|------:|
| 12 |  12 |    12         |
| 3  |    10   |   -10 |
| 7 | | |


- Pop argument(s) from stack
- Compute f on the stack
- Pushed the result back to the stack

So these are all part of the abstraction and happen on the stack automatically

But But Why are we doing all this ? (We look at the big picture)

`x = 17 + 19` in a high level language gets compiled to 

```
push 17
push 19 
add 
pop x
```

Yay stack machine, here are the list of all the Arithmetic and Logical commands 

| Command 	| Return value 	| Return Type 	|
|---------	|--------------	|-------------	|
| Add        	|         x+y     	|     Integer        	|
| Sub     	| x-y             	| Integer            	|
| Neg        	|      -y        	|       Integer      	|
| eq        	|      x==0        	|       Boolean      	|
| gt        	|      x > y       	|       Boolean      	|
| lt        	|      y < x        	|       Boolean      	|
| and        	|      x and y        	|       Boolean      	|
| or        	|      x or y        	|       Boolean      	|
| not        	|      not y        	|       Boolean      	|

---
This is super powerful cause any arithmetic or logical operation can be expressed and evaluated by applying some sequence 
of the above operations on a stack 

---


<b> Memory Segments </b>


High level code has different types of variables, we can have static vars, local vars, arguments and so on. To preserve these roles we use memory segments which are just stacks and once we have these segments in place, the compiler can map the variables of the high level on these segments.

Syntax: `Push/Pop segment i` eg: push local 17

We have 8 mem segments: local, argument, this, that, constant, static, pointer, temp

> Note: You cannot pop a constant

Theory is all good but how do achieve this, so let's refresh pointers 

| RAM 	| Memory |
|---------	|
| 22        | 256 
| 31     	| 257
| 200       | 258
| 28       	| 259

```
p1 = 256
p1 = p1 + 3
*p1 = *p1 + 3
p2 = p1 - 2
p1--
*(p2 + 1) = *p1 + *p2              
```

What will be the value of RAM[258] following the code execution?

```
p1 = 256 // p1 = 256
p1 = 259 // p1 = p1 + 3
RAM[259] = 31 // *p1 = *p1 + 3
p2 = 257 // p2 = p1 - 2
p1 = 258 // p1--
RAM[258] = RAM[257] + RAM[258] // *p1 + *p2 
=> 231
```

So now to push something to a stack we have to do two things, assign the pushed value to SP's memory location following which we increment the stack pointer.

```
# VM CODE 
PUSH CONSTANT 17 
```
|| VM Translator || 

```
# Assembly
*SP = 17
SP++
```

A VM translator is a program that translates VM code to machine language

In our RAM we have a stack pointer and a Base Address that points to a memory segment depending on the type of segment

for example if our base address is 5 for temp memory segment, then

`push temp i` =>  `addr = 5+i, *SP = *addr, SP++`

`pop temp i` =>  `addr = 5+i, SP-- , *addr = *SP`


`This` and `That` memory segments represent the current object and the current array that the method in a high level language maybe processing. We keep the base addresses of this and that in the pointer memory segment

`Push/ Pop pointer 0/1` pointer can be either 0 or 1 (A fixed 1 place segment)

- Accessing 0 should result in accessing THIS

- Accessing 1 should result in accessing THAT

<b> Branching </b>

Now we come to functions and loops, two very powerful high level programming concepts

Todo understand this a low level we divide branching into conditonal and unconditional

- goto label // Jump to execute command just after label

- if-goto label // cond = pop; if cond jump to execute command just after label

- label label // label declaration


With our VM language we have two types of functions

- Primitive Functions like `add` and `sub` that are already defined, so we can just call `add`

- Abstract Functions that we call from somewhere, In our case we call the OS for math.multiply with `call Math.multiply` these have the same look and feel of a primitive function and makes our vm lang extensible


![img](https://i.ibb.co/KwNk2ys/functions-in-vm.png)

We `call mult 2` to denote the number of arguments and `function mult 2` to represent the number of local vars. Return pushes the topmost local var back to the stack before popping the arguments

